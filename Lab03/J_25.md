# 📖 J-25

# 서브 클래스와 슈퍼 클래스의 생성자 호출 및 실행

서브 클래스와 슈퍼 클래스는 각각 생성자를 가지고 있습니다. 

* **서브 클래스 객체가 생성될 때 서브 클래스의 생성자와 슈퍼 클래스의 생성자가 모두 실행되는가? 아니면 서브 클래스의 생성자만 실행되는가?**

둘 다 실행됩니다. 서브 클래스의 객체가 생성되면 이 객체 속에 서브 클래스와 멤버와 슈퍼 클래스의 멤버가 모두 들어 있습니다. 생성자의 목적은 객체 초기화에 있으므로, 서브 클래스의 생성자는 생성된 객체 속에 들어 있는 서브 클래스의 멤버 초기화나 필요한 초기화를 수행하고, 슈퍼 클래스의 생성자는 생성된 객체 속에 있는 슈퍼 클래스의 멤버 초기화나 필요한 초기화를 각각 수행합니다.

* **서브 클래스의 생성자와 슈퍼 클래스의 생성자 중 누가 먼저 실행되는가?**

슈퍼 클래스의 생성자가 먼저 실행된 후 서브 클래스의 생성자가 실행됩니다.

<p>
main() 메소드애서 객체 c를 생성하는 다음 코드를 보겠습니다.
</p>

![image](https://github.com/user-attachments/assets/de6343b2-773a-42a6-b81e-4825559cf484)

<p>
  아래 그림은 상속 관계에 있는 3개의 클래스에 대해 생성자 호출 및 실행 관계를 보여줍니다.
</p>
<p>
  컴파일러는 이 new 문장이 실행되면 즉각 생성자 C()를 호출하게 합니다. 그러나 생성자 C()는 자신의 코드를 실행하기 전에, 먼저 슈퍼 클래스의 생성자 B()를 호출합니다. 생성자 B() 역시 자신의 코드를 실행하기 전에, 슈퍼 클래스인 A의 생성자 A()를 호출합니다. 최종적으로 생성자 A()의 코드가 실행되고, 리턴하여 생성자 B()의 코드가 실행되며, 다시 리턴하여 마지막으로 생성자 C()의 코드가 실행된 후 main()으로 돌아옵니다.
</p>
<p>
  서브 클래스의 생성자가 먼저 호출되지만, 결국 슈퍼 클래스의 생성자가 먼저 실행되고 서브 클래스의 생성자가 나중에 실행됩니다. 컴파일러는 서브 클래스의 생성자에 대해, 슈퍼 클래스의 생성자를 호출한 뒤 자신의 코드를 실행하도록 컴파일합니다. 이것은 당연한 조치로서, 슈퍼 클래스가 먼저 초기화된 후, 이를 활용하는 서브 클래스가 초기화되어야 되기 때문입니다.
</p>

![image](https://github.com/user-attachments/assets/49407738-4102-4a45-a7a3-2dfd62950299)

# 서브 클래스에서 슈퍼 클래스 생성자 선택
<p>
  원칙적으로, 서브 클래스의 개발자가 서브 클래스의 각 생성자에 대해, 함께 실행될 슈퍼 클래스의 생성자를 지정하여야 합니다. 하지만, 개발자가 슈퍼 클래스의 생성자를 명시적으로 지정하지 않는 경우, 컴파일러는 자동으로 슈퍼 클래스의 기본 생성자를 호출하도록 컴파일합니다.
</p>

* **슈퍼 클래스의 기본 생성자가 자동 선택되는 경우**
<p>
   개발자의 명시적 지사가 없으면, 서브 클래스의 생성자가 기본 생성자이든 매개변수를 가진 것이든, 슈퍼 클래스에 만들어진 기본 생성자가 선택됩니다. 이 선택은 자바 컴파일러에 의해 강제로 이루어집니다. 아래 그림의 경우를 살펴보면, 클래스 B는 A를 상속받습니다. 클래스 A에는 2개의 생성자가 작성되어 있지만, 클래스 B의 기본 생성자가 호출되면, 슈퍼 클래스의 기본 생성자 A()가 자동으로 호출됩니다.
</p>

* **서브 클래스 B의 기본 생성자에 대해 슈퍼 클래스 A의 기본 생성자가 묵시적으로 선택**

![image](https://github.com/user-attachments/assets/c2f1ebf8-67d2-402b-baf8-1b02237078d5)

* **슈퍼 클래스 A에 기본 생성자가 없는 경우, 오류 발생**

![image](https://github.com/user-attachments/assets/64d46e06-694d-415c-802e-fbb3968f09b7)

* **서브 클래스 B의 매개변수를 가진 생성자도 슈퍼 클래스의 A의 기본 생성자와 짝을 이룸**

![image](https://github.com/user-attachments/assets/2fbb02bf-d191-4395-942e-ef4681cd624b)

# super()를 이용하여 명시적으로 슈퍼 클래스의 생성자 선택
<p>
  서브 클래스의 생성자에서 슈퍼 클래스의 생성자를 명시적으로 선택하는 것이 원칙입니다. 지금까지는 개발자가 명시적으로 선택하지 않았을 때, 컴파일러가 자동으로 슈퍼 클래스의 기본 생성자를 호출한 사례를 보았습니다.
</p>
<p>
  서브 클래스의 생성자에서 super()를 이용하면, 슈퍼 클래스 생성자를 명시적으로 선택할 수 있습니다. **super()**는 슈퍼 클래스 생성자를 호출하는 코드입니다. 괄호 안에 인자를 전달하여 슈퍼 클래스의 생성자를 호출할 수도 있습니다.
</p>
<p>
  아래 그림에서는 super()를 사용하는 사례를 보여줍니다. 
</p>

* **클래스 B에서 super()를 이용하여 명시적으로 슈퍼 클래스 A의 생성자 선택**

![image](https://github.com/user-attachments/assets/7dcba30e-14d0-4a86-abe0-8cdbaa92f642)

# super()를 활용한 ColorPoint 작성

<p>
  super()를 이용하여 ColorPoint 클래스의 생성자에서 슈퍼 클래스 Point의 생성자를 호출하는 예를 작성했습니다.
</p>

[소스코드](./SuperEx.java) <--click
---

![image](https://github.com/user-attachments/assets/1578dd51-0938-4443-b845-ae6fc6c21ec4)

📘 실행 결과
---

![image](https://github.com/user-attachments/assets/5e355e01-7b3d-41ad-81d7-121e27e10ae1)

# <p align="right">[J-26](./J_26.md)</p>

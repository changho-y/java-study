# 📖 J-18

# 객체의 소멸과 가비지 컬렉션

# 객체의 소멸

자바에는 객체를 생성하는 new 연산자가 있지만 객체를 소멸시키는 연산자는 없습니다. 그러므로 자바에서는 개발자가 마음대로 객체를 소멸시킬 수 없습니다.
<p>객체 소멸이란 new에 의해 생성된 객체 공간을 자바 가상 기계에게 돌려주어 가용 메모리에 포함시키는 것입니다. 자바는 delete 연산자도 소멸자도 없습니다.</p>

# 가비지

가비지란 자바 응용프로그램에서 더 이상 사용되지 않게 된 객체나 배열 메모리입니다. 자바 플랫폼은 참조하는 레퍼런스가 하나도 없는 객체나 배열을 가비지로 판단합니다.

다음 코드를 실행하면 2개의 Person 객체가 생깁니다.

![image](https://github.com/user-attachments/assets/823403c1-b4f2-4688-a229-247f507b776b)

그러고 나서 b = a; 라인을 실행해보면 레퍼런스 b는 a가 가리키던 객체를 가리키게 되고, b가 가리키던 처음 객체는 아무도 참조하지 않게 되어 더 이상 접근할 수 없게 됐습니다. 이 객체가 바로 가비지입니다.

![image](https://github.com/user-attachments/assets/e681b87c-c36b-477b-a013-da5502614af5)

[소스코드](./GarbageEx.java) <--click
---

![image](https://github.com/user-attachments/assets/d54c251f-835c-4dd8-94b5-8e45b158a456)

📘 실행 결과
---

어떤 레퍼런스도 가리키고 있지 않는 객체나 배열이 가비지가 됩니다.

![image](https://github.com/user-attachments/assets/ca1bbcad-20e4-405a-98b4-9ff29a8a2e84)

# 가바지 컬렉션

가비지는 더 이상 참조되지 않기 때문에 가비지가 차지하고 있는 메모리 공간은 회수되어야 합니다. 가비지가 많아지면 자바 플랫폼이 응용프로그래에게 할당해줄 수 있는 가용 메모리 양이 줄어들게 됩니다. 시간이 지날수록 자연히 가비지가 늘어나게 되며, 최악의 경우 자바 플랫폼의 가용 메모리가 0이 되면 자바 응용프로그램은 더 이상 실행될 수 없게 됩니다.
<p>이런 경우를 대비하여 자바 플랫폼은 가용 메모리가 일정 크기 이하로 줄어들면 자동으로 가비지를 회수하여 가용 메모리를 늘립니다. 이것을 가비지 컬렉션이라고 부르며, 가비지 컬렉션은 자바 플랫폼에 의해 준비된 가비지 컬렉션 스레드에 의해 처리됩니다.</p>

# 가비지 컬렉션 강제 요청

응용프로그램에서 System 또는 Runtime 객체의 gc() 메소드를 호출하면 가비지 컬렉션을 요청할 수 있습니다. 간단히 다음 한 줄의 코드로 가능합니다.

![image](https://github.com/user-attachments/assets/c4662084-a224-41f1-9a20-47d7ce3927c9)

그러나 이 문장을 호출한 즉시 가비지 컬렉터가 작동하는 것은 아닙니다. 이 문장은 가비지 컬렉션이 필요하다는 요청에 불과합니다. 가비지 컬렉션은 자바 플랫폼이 전적으로 판단하여 적절한 시점에 작동시킵니다.

# <p align="right">[J-19](./J_19.md)</p>
